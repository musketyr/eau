#summary Qualifying Assignments
#sidebar TableOfContents
#labels EarlyDraft

<wiki:toc max_depth="3" />

= Qualifying assignments =

Nowadays there is plenty of *Unit, Test* and other testing frameworks which 
helps us to test nearly everything. There are also a lot of tools like continuous 
integration servers which helps us to report their results. But there is one 
important problem.  Are they all tests equal?

----
_*Implement vehicle based on given interface. The following features will be scored:*_
|| *Points* || *Requirements* ||
|| 4 || vehicle must change its direction appropriately when turning left or right ||
|| *Points* || *Bonus features* ||
|| 1 || vehicle might show proper blinker before and during turning left or right || 

----

Here we have desired interface:
{{{
public interface Vehicle {
    Direction getDirection();
    void turnLeft();
    void turnRight();
    void prepareTurnLeft();
    void prepareTurnRight();
    boolean isLeftBlinkerOn();
    boolean isRightBlinkerOn();
}
}}}

And here is one of final works. The veteran car.

{{{
public class VeteranCar implements Vehicle{     
    
    private Direction direction = Direction.NORTH;  
    
    @Override public Direction getDirection() { return direction; }
    @Override public boolean isLeftBlinkerOn() { return false; }
    @Override public boolean isRightBlinkerOn() { return false; }
    @Override public void prepareTurnLeft() {}  
    @Override public void prepareTurnRight() {}
    @Override public void turnLeft() { direction = direction.left(); }
    @Override public void turnRight() { direction = direction.right(); }  
}
}}}
As we see blinkers are not supported by this car so the author will get no extra points
but still she should get all required points.

We can write a simple test to check whether student's implementation works as it 
should. It could look like one this:

{{{
public class VehicleTest01 {
    protected Vehicle fixture;
    
    // setup and other tests
    
    @Test public void testTurnRight(){
		Direction original = fixture.getDirection();
		fixture.turnRight();
		assertEquals(original.right(), fixture.getDirection());
    }
    
    @Test public void testPrepareRight(){
		Direction original = fixture.getDirection();
		fixture.prepareTurnRight();
		assertEquals(original, fixture.getDirection());
		assertTrue(fixture.isRightBlinkerOn());
		assertFalse(fixture.isLeftBlinkerOn());
    }
}
}}}

And here is the problem. Importance of {{{testTurnRight}}} is much higher than 
{{{testPrepareRight}}}, but there is no sign about this in the code. So there is no 
way how to find out how many points does particular student get until we match 
test results with the original assignment. But there can be some better way. We 
can make special annotations which will help us to have everything on one place. 
Look on next code snippet. The points are divided by two because we can turn into
two directions.

{{{
public class VehicleTest02 {

    protected Vehicle fixture;
    
    // setup and other tests
    
    @Points(2)
    @Test public void testTurnRight(){
		Direction original = fixture.getDirection();
		fixture.turnRight();
		assertEquals(original.right(), fixture.getDirection());
    }
    
    @Points(0.5)
    @Test public void testPrepareRight(){
		Direction original = fixture.getDirection();
		fixture.prepareTurnRight();
		assertEquals(original, fixture.getDirection());
		assertTrue(fixture.isRightBlinkerOn());
		assertFalse(fixture.isLeftBlinkerOn());
    }   
}
}}}

We can even provide lot of more useful informations like tasks description and
that some test is testing bonus feature. Bonus feature is as expected the one which
gives some extra points.

{{{
public class VehicleTest03 {

    protected Vehicle fixture;
    
    // setup and other tests
    
    @Points(2)
    @Description("Vehicle changes direction to proper one after turning right")
    @Test public void testTurnRight(){
		Direction original = fixture.getDirection();
		fixture.turnRight();
		assertEquals(original.right(), fixture.getDirection());
    }
    
    @Bonus @Points(0.5)
    @Description("Vehicle blinks right when preparing to turn right")
    @Details("Vehicle must keep original direction when preparing to turn")
    @Test public void testPrepareRight(){
		Direction original = fixture.getDirection();
		fixture.prepareTurnRight();
		assertEquals(original, fixture.getDirection());
		assertTrue(fixture.isRightBlinkerOn());
		assertFalse(fixture.isLeftBlinkerOn());
    }
}
}}}

Usage of this annotations is quite straightforward. They all can be found in
{{{eu.ebdit.eau}}} package of [http://code.google.com/p/eau EAU project]. They 
can be used at method or class level. By annotating single test we say that
if this test is successful author should get particular number of points. By annotating
whole test class we say that some points should be given to author when all tests passes.

For example plane must be able to take off and also land safely:

{{{
@Points(10)
@Description("Plane must take off and land safely!")
public class PlaneTest {
	@Test testTakeOff(){...}
	@Test testLand(){...}
}
}}}

Following table describes basic usage of annotations from {{{eu.ebdit.eau}}} package:

||*Annotation*||*Value*||*Usage*||
||*Bonus*||_None_||Marks test as optional. Failing the test will author not loose any important points but can gain extra ones.||
||*Description*||Short and meaningful description of test||Provide short and meaningful description for given test. This description will be shown in evaluation report.||
||*Details*||Additional details about the test||Provide additional details about the test. This details can be used for evaluating tools to provide more information about the test.||
||*Points*||Number of points if successful||Provide number of points for evaluation. The number can be any {{{double}}}. Negative numbers will be converted to their positive counterparts using absolute value. Zero value should not be used since there is no meaningful how to decide whether the test was successful after evaluation. *This annotation must be always present on test method or class otherwise the method or class will not be taken into account during evaluation!*||

